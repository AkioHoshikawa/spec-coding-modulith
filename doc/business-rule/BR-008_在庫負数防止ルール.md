# BR-008: 在庫負数防止ルール

## 基本情報

| 項目 | 内容 |
|------|------|
| **ルールID** | BR-008 |
| **ルール名** | 在庫負数防止ルール |
| **カテゴリ** | 在庫管理 |

## 概要

### 目的
在庫数が負数になることを絶対に防止し、データ整合性を保つ。在庫負数は在庫管理の重大な不整合であり、オーバーセル（過剰販売）や会計上の問題を引き起こす。システムレベルで在庫負数を検出・防止し、発生時には即座にアラートを発行することで、ビジネスへの影響を最小限に抑える。

### 適用範囲
- 在庫引当処理
- 在庫更新処理（入荷、出荷、キャンセル、返品）
- 在庫データの整合性チェック
- 在庫負数の検出とアラート
- データベース制約による防止

## ルール詳細

### ビジネスルール記述

#### 前提条件
- 在庫データはSKU単位でInventoryLocationテーブルに保持されている
- 在庫数には物理在庫数（physical_qty）と引当済み数量（allocated_qty）が存在する
- データベースにはCHECK制約が設定されている
- 在庫操作は必ずトランザクション内で実行される
- 在庫の監視システムが稼働している

#### ルールステートメント
**IF（条件）**
- 在庫の引当、出荷、その他の操作により在庫数が減少する
- または、在庫データの更新が試みられる

**THEN（アクション/結果）**
- **アプリケーションレベルでの防止**:
  1. 在庫更新前に必ず残高チェックを実行
  2. 利用可能在庫数 = 物理在庫数 - 引当済み数量
  3. 利用可能在庫数 < 0 となる更新は拒否
  4. 引当済み数量 > 物理在庫数 となる状態も拒否

- **データベースレベルでの防止**:
  1. CHECK制約: physical_qty >= 0
  2. CHECK制約: allocated_qty >= 0
  3. CHECK制約: allocated_qty `<=` physical_qty
  4. 制約違反時はトランザクションをロールバック

- **検出時の対応**:
  1. エラーログに詳細を記録（SKU、操作内容、現在値、試行値）
  2. 即座にアラートを発行（Slack、メール、監視ツール）
  3. 管理者ダッシュボードに異常を表示
  4. 該当SKUの注文を一時停止（オプション）
  5. インシデント対応フローを起動

**ELSE（代替アクション）**
- 在庫更新が正常な範囲内の場合、処理を続行
- 定期的な整合性チェックでも異常が検出されない場合、正常と判断

#### 制約条件
- **データベース制約**:
  ```sql
  ALTER TABLE inventory_location
  ADD CONSTRAINT chk_physical_qty_non_negative 
    CHECK (physical_qty >= 0);
  
  ALTER TABLE inventory_location
  ADD CONSTRAINT chk_allocated_qty_non_negative 
    CHECK (allocated_qty >= 0);
  
  ALTER TABLE inventory_location
  ADD CONSTRAINT chk_allocated_lte_physical 
    CHECK (allocated_qty <= physical_qty);
  ```

- **アプリケーション制約**:
  - 在庫引当前に必ず残高チェックを実行
  - 在庫更新はトランザクション内で実行し、失敗時はロールバック
  - 在庫負数が検出された場合、該当SKUの注文を一時停止

- **監視・アラート**:
  - 在庫負数検出時は即座にアラート（P0インシデント）
  - 在庫負数の発生回数を監視（月次レポート）
  - 在庫データの整合性を毎日バッチでチェック

### ビジネスロジック

#### 計算式・アルゴリズム
```
在庫更新前のチェック:

FUNCTION safe_allocate_inventory(sku, location, qty):
  BEGIN TRANSACTION
    # 1. 在庫レコードを取得（排他ロック）
    inventory = SELECT * FROM inventory_location 
                WHERE sku = :sku AND location = :location
                FOR UPDATE
    
    # 2. 利用可能在庫を計算
    available = inventory.physical_qty - inventory.allocated_qty
    
    # 3. 引当可否をチェック
    IF available < qty THEN
      ROLLBACK
      RETURN error("在庫不足: 利用可能=" + available + ", 要求=" + qty)
    END IF
    
    # 4. 引当後の状態をシミュレーション
    new_allocated = inventory.allocated_qty + qty
    
    # 5. 負数チェック（二重チェック）
    IF new_allocated < 0 OR new_allocated > inventory.physical_qty THEN
      ROLLBACK
      log_error("在庫負数の危険を検出", {sku, location, new_allocated})
      send_alert("在庫負数リスク検出", P0)
      RETURN error("在庫更新エラー")
    END IF
    
    # 6. 在庫を更新
    UPDATE inventory_location
    SET allocated_qty = new_allocated,
        updated_at = CURRENT_TIMESTAMP
    WHERE sku = :sku AND location = :location
    
    # 7. トランザクションログ記録
    INSERT INTO inventory_transaction (...)
    
  COMMIT
  RETURN success


在庫整合性チェック（バッチ処理）:

FUNCTION check_inventory_integrity():
  # 1. 負数の在庫を検出
  negative_inventories = SELECT * FROM inventory_location
                         WHERE physical_qty < 0 
                            OR allocated_qty < 0
                            OR allocated_qty > physical_qty
  
  IF negative_inventories.count > 0 THEN
    FOR EACH inv IN negative_inventories:
      log_critical("在庫負数検出", {
        sku: inv.sku,
        location: inv.location,
        physical_qty: inv.physical_qty,
        allocated_qty: inv.allocated_qty
      })
      
      send_alert("在庫負数検出", {
        severity: P0,
        sku: inv.sku,
        details: inv
      })
      
      # 該当SKUの注文を一時停止
      suspend_orders_for_sku(inv.sku)
    END FOR
  END IF
  
  # 2. トランザクションログとの整合性チェック
  FOR EACH inventory IN all_inventories:
    calculated_qty = calculate_from_transactions(inventory.sku)
    IF calculated_qty != inventory.physical_qty THEN
      log_warning("在庫不整合検出", {
        sku: inventory.sku,
        db_qty: inventory.physical_qty,
        calculated_qty: calculated_qty,
        diff: calculated_qty - inventory.physical_qty
      })
      send_alert("在庫不整合", {severity: P1, ...})
    END IF
  END FOR


在庫負数発生時のリカバリ:

FUNCTION recover_negative_inventory(sku, location):
  BEGIN TRANSACTION
    # 1. 在庫トランザクション履歴を分析
    transactions = SELECT * FROM inventory_transaction
                   WHERE sku = :sku AND location = :location
                   ORDER BY created_at DESC
    
    # 2. 理論上の正しい在庫数を計算
    correct_qty = calculate_correct_inventory(transactions)
    
    # 3. 管理者に確認を求める
    approval = request_admin_approval({
      sku: sku,
      current_qty: inventory.physical_qty,
      calculated_qty: correct_qty,
      transactions: transactions
    })
    
    IF approval.approved THEN
      # 4. 在庫を修正
      UPDATE inventory_location
      SET physical_qty = :correct_qty,
          allocated_qty = MIN(allocated_qty, correct_qty)
      WHERE sku = :sku AND location = :location
      
      # 5. 修正ログを記録
      INSERT INTO inventory_adjustment_log (
        sku, location, old_qty, new_qty, reason, approved_by
      )
    END IF
  COMMIT
```

#### 判定基準
- **在庫負数の深刻度**:
  - P0（緊急）: physical_qty < 0 または allocated_qty > physical_qty
    - 即座にアラート、該当SKUの注文停止、手動対応
  - P1（高）: トランザクションログと在庫数の不整合
    - 24時間以内に調査・修正
  - P2（中）: 在庫数が0に近い（セーフティストック未満）
    - 発注アラート

- **リカバリの優先度**:
  1. データ整合性の回復（在庫負数の修正）
  2. 原因分析（どの処理で負数が発生したか）
  3. 再発防止策の実施（コード修正、制約追加）

#### 例外処理
- **データベース制約違反**: トランザクションをロールバックし、エラーログに記録
- **在庫負数検出**: 即座にアラートを発行し、該当SKUの注文を停止
- **トランザクションログ不整合**: 管理者に通知し、手動調査を依頼
- **リカバリ失敗**: エスカレーションフローに従い、上位管理者に連絡

## 具体例

### ケース1: 正常系 - 在庫引当成功
**シナリオ:**
十分な在庫がある状態で、正常に在庫引当が行われる。

**入力:**
- SKU: SHIRT-001
- Location: 東京倉庫
- 物理在庫数: 100
- 引当済み数量: 30
- 引当リクエスト: 5

**処理の流れ:**
```
1. 利用可能在庫計算: 100 - 30 = 70
2. 引当可否チェック: 70 >= 5 → OK
3. 引当後シミュレーション: 30 + 5 = 35
4. 負数チェック: 35 >= 0 AND 35 <= 100 → OK
5. 在庫更新: allocated_qty = 35
```

**期待される出力:**
- 引当: 成功
- 引当後の allocated_qty: 35
- 利用可能在庫: 65
- アラート: なし

### ケース2: 異常系 - 在庫不足による引当失敗
**シナリオ:**
利用可能在庫が不足しており、引当が拒否される。

**入力:**
- SKU: JACKET-002
- 物理在庫数: 50
- 引当済み数量: 48
- 引当リクエスト: 5

**処理の流れ:**
```
1. 利用可能在庫計算: 50 - 48 = 2
2. 引当可否チェック: 2 >= 5 → NG
3. トランザクションロールバック
4. エラー返却
```

**期待される出力:**
- 引当: 失敗
- エラーメッセージ: "在庫不足: 利用可能=2, 要求=5"
- 在庫数: 変更なし（physical_qty=50, allocated_qty=48）
- アラート: なし（正常なエラーハンドリング）

### ケース3: 重大異常 - 在庫負数検出
**シナリオ:**
システムのバグにより、在庫負数が発生してしまう（本来は防止されるべき）。

**入力:**
- SKU: LIMITED-ITEM
- 物理在庫数: 10
- 引当済み数量: 12（異常状態）

**検出時の処理:**
```
1. バッチ処理で整合性チェック実行
2. 異常検出: allocated_qty (12) > physical_qty (10)
3. 即座にアラート発行:
   - Severity: P0
   - Message: "在庫負数検出: SKU=LIMITED-ITEM, physical=10, allocated=12"
4. 該当SKUの注文を一時停止
5. 管理者ダッシュボードに表示
6. インシデント対応フロー起動
```

**期待される出力:**
- アラート: P0（緊急）
- 注文停止: LIMITED-ITEM の新規注文を停止
- ログ: 詳細なエラーログ記録
- 対応: 手動調査・修正が必要

### ケース4: データベース制約による防止
**シナリオ:**
アプリケーションのバグで負数更新が試みられるが、データベース制約で防止される。

**入力:**
- SKU: COAT-003
- 現在の physical_qty: 20
- バグのある更新クエリ: SET physical_qty = -5

**処理の流れ:**
```
1. UPDATE文実行
2. データベースがCHECK制約違反を検出
3. トランザクション自動ロールバック
4. アプリケーションにエラー返却
```

**期待される出力:**
- 更新: 失敗（制約違反）
- エラー: "CHECK constraint violation: physical_qty >= 0"
- 在庫数: 変更なし（20のまま）
- ログ: エラーログに記録、開発チームに通知
- アラート: バグ検出アラート発行

## 関連ルール
- BR-001: 在庫引当とロック機構
- BR-003: 在庫競合制御
- BR-006: 決済失敗時の在庫ロールバック

## 備考・補足事項

### 注意事項
- 在庫負数は重大なデータ不整合であり、絶対に防止する必要がある
- アプリケーションレベルとデータベースレベルの多層防御を実装すること
- 在庫負数が検出された場合は、ビジネスへの影響を最小限に抑えるため、即座に対応すること
- 在庫トランザクションログは詳細に記録し、原因分析に活用すること
- 定期的な整合性チェックにより、潜在的な問題を早期に発見すること
