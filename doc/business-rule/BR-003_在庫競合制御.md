# BR-003: 在庫競合制御

## 基本情報

| 項目 | 内容 |
|------|------|
| **ルールID** | BR-003 |
| **ルール名** | 在庫競合制御 |
| **カテゴリ** | 在庫管理 |

## 概要

### 目的
セールやタイムセール時など、同一SKUに対して多数のユーザーが同時に注文確定を実行する状況において、在庫の二重引当や在庫負数を防止し、データ整合性を保つための排他制御メカニズムを提供する。特にピーク時（秒間数千リクエスト想定）でも在庫整合性を保つことが目的。

### 適用範囲
- 在庫引当処理
- 在庫更新処理（入荷、出荷、キャンセル時の戻し）
- 在庫数の参照処理（利用可能在庫の確認）
- 同時アクセスが想定される全ての在庫操作

## ルール詳細

### ビジネスルール記述

#### 前提条件
- 在庫データはSKU単位でInventoryLocationテーブルに保持されている
- 在庫引当処理はトランザクション内で実行される
- データベースは楽観ロック（Optimistic Locking）または悲観ロック（Pessimistic Locking）をサポートしている
- 高負荷時のリトライ処理が実装されている

#### ルールステートメント
**IF（条件）**
- 同一SKUに対して複数のユーザーから同時に在庫引当リクエストが発生する
- 在庫更新処理が競合する可能性がある
- トランザクション分離レベルがREAD COMMITTEDまたはそれ以上に設定されている

**THEN（アクション/結果）**
- **楽観ロック方式**（推奨）:
  1. 在庫レコードにバージョン番号（version）を保持する
  2. 在庫引当時にバージョン番号を含めてレコードを読み取る
  3. 更新時にバージョン番号が変更されていないことを確認する
  4. 変更されていた場合は更新失敗とし、リトライする
  5. 成功時はバージョン番号をインクリメントする
  
- **悲観ロック方式**（在庫負数を絶対に許容しない場合）:
  1. 在庫レコードに対してSELECT FOR UPDATE（行ロック）を取得する
  2. ロック取得後に利用可能在庫数を確認する
  3. 引当可能であれば在庫数を更新する
  4. トランザクションコミット時にロックを解放する

- **リトライ処理**:
  - 楽観ロック競合時は最大3回までリトライする
  - リトライ間隔は指数バックオフ（100ms, 200ms, 400ms）
  - 3回失敗した場合はユーザーに一時的なエラーを通知する

**ELSE（代替アクション）**
- ロック取得タイムアウト時はエラーを返す
- リトライ上限到達時は一時的なエラーを返す
- データベース接続エラー時はシステムエラーを返す

#### 制約条件
- ロック保持時間は最小限に抑える（目標: 100ms以内）
- トランザクション内での外部API呼び出しは禁止（デッドロック防止）
- 在庫更新は必ずトランザクション内で実行する
- 在庫負数を検出した場合は即座にアラートを発行する
- 楽観ロック競合率が10%を超えた場合はアラートを発行する

### ビジネスロジック

#### 計算式・アルゴリズム
```
楽観ロック方式のアルゴリズム:

BEGIN TRANSACTION
  
  # 1. 在庫レコードを読み取る（バージョン番号含む）
  inventory = SELECT * FROM inventory_location 
              WHERE sku = :sku AND location = :location
  current_version = inventory.version
  available_qty = inventory.physical_qty - inventory.allocated_qty
  
  # 2. 引当可否をチェック
  IF available_qty < requested_qty THEN
    ROLLBACK
    RETURN error("在庫不足")
  END IF
  
  # 3. 在庫を更新（バージョン番号をWHERE句に含める）
  updated_rows = UPDATE inventory_location
                 SET allocated_qty = allocated_qty + :requested_qty,
                     version = version + 1,
                     updated_at = CURRENT_TIMESTAMP
                 WHERE sku = :sku 
                   AND location = :location
                   AND version = :current_version
  
  # 4. 更新成功確認
  IF updated_rows == 0 THEN
    # 楽観ロック競合発生
    ROLLBACK
    RETURN retry_needed
  END IF
  
  # 5. トランザクションログを記録
  INSERT INTO inventory_transaction (...)
  
COMMIT

リトライロジック:
FOR retry_count = 1 TO 3:
  result = execute_inventory_allocation()
  IF result == success THEN
    RETURN success
  ELSE IF result == retry_needed THEN
    WAIT exponential_backoff(retry_count)
    CONTINUE
  ELSE
    RETURN error
  END IF
END FOR
RETURN error("リトライ上限到達")
```

#### 判定基準
- **楽観ロック vs 悲観ロック の選択基準**:
  - 競合率が低い（< 5%）: 楽観ロックを使用（パフォーマンス優先）
  - 競合率が高い（> 10%）: 悲観ロックまたは分散ロック（Redis等）を検討
  - 在庫負数が絶対に許容できない: 悲観ロックを使用

- **リトライ判定**:
  - 楽観ロック競合: リトライする
  - 在庫不足: リトライしない（即座にエラー返却）
  - タイムアウト: リトライしない
  - システムエラー: リトライしない

#### 例外処理
- **デッドロック検出**: データベースがデッドロックを検出した場合、トランザクションを自動ロールバックし、リトライする
- **在庫負数検出**: 在庫が負数になった場合は即座にアラートを発行し、管理者に通知する（データ不整合として扱う）
- **ロックタイムアウト**: 5秒以内にロックが取得できない場合はタイムアウトエラーを返す
- **高負荷時の制御**: 同時リクエスト数が閾値を超えた場合、レート制限を適用する

## 具体例

### ケース1: 正常系 - 楽観ロック成功
**シナリオ:**
2人のユーザーがほぼ同時に同じSKU（SHIRT-001）を注文する。

**入力:**
- ユーザーA: SHIRT-001を2点注文
- ユーザーB: SHIRT-001を3点注文
- 現在の在庫: 物理在庫100、引当済み20、バージョン5

**処理の流れ:**
```
時刻T1: ユーザーAのリクエスト開始
  - 在庫読取: 物理100、引当済み20、version=5
  - 利用可能: 80

時刻T2: ユーザーBのリクエスト開始（T1とほぼ同時）
  - 在庫読取: 物理100、引当済み20、version=5
  - 利用可能: 80

時刻T3: ユーザーAの更新実行
  - UPDATE ... SET allocated_qty = 22, version = 6 WHERE version = 5
  - 成功（version=6に更新）

時刻T4: ユーザーBの更新実行
  - UPDATE ... SET allocated_qty = 25, version = 6 WHERE version = 5
  - 失敗（versionが既に6に変更されている）
  - リトライ処理へ

時刻T5: ユーザーBのリトライ
  - 在庫再読取: 物理100、引当済み22、version=6
  - 利用可能: 78（3点引当可能）
  - UPDATE ... SET allocated_qty = 25, version = 7 WHERE version = 6
  - 成功
```

**期待される出力:**
- ユーザーA: 引当成功（引当数: 2）
- ユーザーB: リトライ後に引当成功（引当数: 3）
- 最終的な引当済み数量: 25
- データ整合性: 保たれている

### ケース2: 異常系 - リトライ上限到達
**シナリオ:**
タイムセール開始直後、100人のユーザーが同時に同じSKU（限定商品）を注文する。

**入力:**
- 100人のユーザーが同時リクエスト
- 現在の在庫: 利用可能10点のみ
- 高い競合率が発生

**期待される出力/エラー:**
- 最初の10人: 引当成功（リトライ含む）
- 残りの90人: 在庫不足エラー（リトライなし）
- 一部のユーザー: リトライ上限到達エラー（一時的に再試行を促す）
- エラーメッセージ: "現在、アクセスが集中しています。少し時間をおいて再度お試しください。"
- 監視アラート: 楽観ロック競合率が閾値超過を検出

### ケース3: 境界値 - 在庫ゼロからの復活
**シナリオ:**
在庫がゼロの状態から、キャンセルによる在庫戻しと新規注文が同時に発生する。

**入力:**
- 現在の在庫: 物理10、引当済み10、利用可能0、version=15
- イベント1: ユーザーCが3点のキャンセル（引当解除）
- イベント2: ユーザーDが2点の新規注文（ほぼ同時）

**期待される出力:**
- キャンセル処理: 引当済み 10 → 7、version 15 → 16
- 新規注文処理: リトライ後に成功、引当済み 7 → 9、version 16 → 17
- 最終的な利用可能在庫: 1点
- データ整合性: 保たれている

## 関連ルール
- BR-001: 在庫引当とロック機構
- BR-008: 在庫負数防止ルール
- BR-006: 決済失敗時の在庫ロールバック

## 備考・補足事項

### 注意事項
- 楽観ロック競合率は常時監視し、閾値を超えた場合は悲観ロックや分散ロック（Redis）への切り替えを検討する
- 在庫更新のトランザクションは可能な限り短時間で完了させる（目標: 100ms以内）
- タイムセールなど予測可能な高負荷イベント時は、事前にキャッシュウォームアップやスケールアウトを実施する
- 在庫負数が検出された場合は、データ修復手順に従って即座に対応する
- 将来的に分散データベースやマイクロサービス化を検討する場合、分散トランザクション（Saga パターンなど）を考慮する
