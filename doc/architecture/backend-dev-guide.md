# 開発ガイドライン (Backend)

このドキュメントは、バックエンド開発におけるルールと方針をまとめたものです。
高校生レベルの語彙でも理解できるように、専門用語には簡単な説明を加え、具体的で簡潔に記述します。

## コーディング規約

### 基本方針
- **言語**: Java 17 を使用します。
- **フレームワーク**: Spring Boot 3.5系、Spring Modulith 1.4系を使用します。
- **文字コード**: UTF-8 (BOMなし) とします。
- **インデント**: タブ文字を使用します（プロジェクト設定に従う）。

### 命名規則
- **クラス名**: `OrderController`, `OrderEntity` のように、大文字で始まるキャメルケース（PascalCase）を使います。
- **メソッド・変数名**: `createOrder`, `itemId` のように、小文字で始まるキャメルケース（camelCase）を使います。
- **定数**: `MAX_RETRY_COUNT` のように、すべて大文字でアンダースコア区切り（SNAKE_CASE）を使います。
- **パッケージ**: `com.example.modulith.poc` をルートとし、すべて小文字を使います。

### パッケージ構成
機能ごとにパッケージを分ける「モジュリス（Modulith）」構成を採用しています。

- `model.{モジュール名}`: ビジネスロジック（在庫、注文など）を格納します。
    - `entity`: データベースのテーブルに対応するクラス。
    - `repository`: データベース操作を行うクラス。
    - `service`: 複雑な処理を行うクラス。
    - `eventlistener`: イベントを受け取って処理するクラス。
- `channel.{チャネル名}`: 外部とのやり取り（Web APIなど）を格納します。
    - `web.controller`: APIのリクエストを受け付けるクラス。
- `core`: 共通で使う便利な機能を格納します。

## ドメイン設計とレイヤリング

### 各層の役割
1.  **Web層 (Channel)**
    - ユーザーからのリクエストを受け取り、結果を返します。
    - ロジックは書かず、イベントを発行して処理を依頼します。
2.  **ドメイン層 (Model)**
    - アプリケーションの中心となるルールやデータを扱います。
    - 他のモジュールとは「イベント」を使ってやり取りし、直接依存することを避けます。

### イベント駆動アーキテクチャ
このプロジェクトでは、処理の依頼や連携に「イベント」を多用します。
- **Controller**: リクエストを受け取ると `OrderCreate` のようなイベントを発行し、処理完了のイベントを待ちます。
- **Listener**: イベントを受け取り、実際の処理（在庫確保など）を行います。

## API設計と互換性

### REST API
- 基本的に REST スタイルで設計します。
- URLはリソース（モノ）を表す名詞を使います（例: `/order/create`）。

### 非同期処理
- Web API は `Reactor (Mono/Flux)` を使った非同期処理に対応しています。
- 内部処理がイベント経由で行われるため、レスポンスが返るまで少し時間がかかる場合があります。

### OpenAPI
- API の仕様書は OpenAPI (Swagger) 形式で管理します。
- 自動生成ツールを使って、コードと仕様書のズレを防ぎます。

## データベースとマイグレーション

### データベース
- 開発・テスト環境では `H2 Database`（メモリ上で動くDB）を使用します。
- 本番環境では `PostgreSQL` を使用します。

### データアクセス
- `Spring Data JPA` を使用してデータベースを操作します。
- SQL を直接書くのではなく、Repository インターフェースを使います。

### トランザクション
- データの整合性を保つため、`@Transactional` アノテーションを使ってトランザクション管理を行います。
- イベントの発行とデータベースの更新は、一貫性が保たれるように注意します。

## エラーハンドリングとバリデーション

### 入力チェック
- `jakarta.validation` (`@NotNull`, `@Size` など) を使って、入り口でデータをチェックします。

### エラーレスポンス
- エラーが発生した場合は、適切な HTTP ステータスコード（400, 404, 500など）と、分かりやすいエラーメッセージを返します。

## ロギング・監視・アラート

### ログ出力
- `System.out.println` は使わず、ログライブラリ（Slf4jなど）を使います。
- 開発中は `DEBUG` レベルで詳細を出力し、本番では `INFO` 以上を出力するように設定します。
- `application.yaml` でログレベルを管理しています。

## テスト戦略

### テストの種類
- **ユニットテスト**: クラス単体の動作を確認します。
- **統合テスト**: モジュール間の連携や、データベースとの接続を確認します。
    - `@ApplicationModuleTest` を使って、モジュールごとのテストを行います。

### テストの方針
- ロジックを含むクラスには必ずテストを書きます。
- バグ修正時は、再現テストを書いてから修正します。

## 依存関係とバージョン管理

### ライブラリ管理
- `Gradle` を使ってライブラリを管理しています。
- `build.gradle` に必要なライブラリを記述します。

## ブランチ戦略とコードレビュー

### ブランチ運用
- `main`: 常に動作する最新の状態を保ちます。
- `feature/xxx`: 新機能の開発や修正を行うためのブランチです。

### コミットメッセージ
Conventional Commits に従います。
形式: `type: subject`

- **type**:
    - `feat`: 新機能
    - `fix`: バグ修正
    - `docs`: ドキュメントのみの変更
    - `style`: コードの動作に影響しない変更（フォーマットなど）
    - `refactor`: リファクタリング（機能追加やバグ修正を含まない）
    - `test`: テストの追加・修正
    - `chore`: ビルドプロセスやツールの変更
- **subject**: 変更内容を簡潔に記述します（日本語可）。

### プルリクエスト (PR)
- コードを変更したら、PR を作成してレビューを依頼します。
- レビューでは、コードの分かりやすさ、テストの有無、規約違反がないかを確認します。