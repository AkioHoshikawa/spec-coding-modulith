# ユーザーストーリー：注文確定時の在庫ロック

## 基本情報

| 項目 | 内容 |
|------|------|
| **ID** | US-001 |
| **タイトル** | 注文確定時にSKU単位で在庫を確実にロックしてオーバーセルを防止する |
| **ステータス** | Draft |
| **優先度** | High |
| **見積もり** | 8ストーリーポイント |
| **担当者** | 未割当 |
| **作成日** | 2025-11-11 |
| **更新日** | 2025-11-11 |

## ユーザーストーリー

**As a** 購入しようとする顧客  
**I want** 注文確定時に選択した商品の在庫が確実に確保される  
**So that** 同一SKUへの同時購入により在庫不足や二重販売が発生しない

### 日本語記述

購入しようとする顧客として、安心して購入を完了するために、注文確定時に選択した商品の在庫が確実に確保され、同一SKUへの同時購入により在庫不足や二重販売が発生しない仕組みが必要である。

## 背景・目的

### ビジネス背景
ファッションECでは、セールやタイムセール時に秒間数千のリクエストが集中し、同一商品への同時注文が頻発する。在庫ロック機構が不十分だとオーバーセル（販売可能数を超えた受注）が発生し、顧客への謝罪・キャンセル対応が必要となり、ブランド信頼性の低下につながる。プロジェクト概要では「ピーク時における在庫整合性の保持」が最重要要件として定義されている。

### ユーザーニーズ
- **顧客視点**: 注文確定ボタンを押した時点で在庫が確保されていることを保証してほしい
- **運営視点**: オーバーセルによる顧客対応コストとブランド毀損を回避したい
- **倉庫視点**: 確定した注文数と実在庫が必ず一致していてほしい

### 現状の課題
- カート追加時の在庫チェックと注文確定時の在庫状況にタイムラグがある
- 複数ユーザーが同時に注文確定すると在庫数の更新競合が発生する
- 決済失敗時の在庫ロック解放が適切に行われない場合がある

## 受入基準（Acceptance Criteria）

### 機能要件

#### AC-1: 並列注文での在庫オーバーロック防止
**Given** SKU Aの利用可能在庫が10件、複数のユーザーが同時に購入処理を行っている  
**When** 複数ユーザーが数量1で注文確定を同時に送信する（1000並列リクエスト）  
**Then** 在庫はリクエスト順に順次ロックされ、最終的にロック数が利用可能在庫を超えない（合計ロック数 ≤ 10）

**詳細説明:**
- 在庫ロック処理は原子操作（Atomic Operation）で実装
- データベースの楽観ロックまたは悲観ロックを使用
- 在庫不足で注文できなかったユーザーには明確なエラーメッセージを返す
- 在庫ロックIDを発行し、OrderLineに記録して追跡可能にする
- 在庫ロック処理のタイムアウトは5秒

#### AC-2: 在庫不足時の明確なエラー通知
**Given** SKU Aの利用可能在庫が0件  
**When** ユーザーが注文確定を試みる  
**Then** 「申し訳ありません。在庫不足のため注文できませんでした」というメッセージが表示される

**詳細説明:**
- エラーレスポンスには不足しているSKU情報を含める
- HTTPステータスコード409（Conflict）を返す
- 在庫ロックは一切行わない
- カート画面に戻り、在庫切れ商品をハイライト表示

#### AC-3: 決済失敗時の在庫ロック自動解放
**Given** 注文確定後に決済処理が失敗した  
**When** 決済失敗イベントを受け取る  
**Then** 該当注文で保持した在庫ロックは即時に解放され、在庫数が復元される

**詳細説明:**
- 在庫ロック解放はInventoryTransactionに記録
- 解放理由「決済失敗」を記録
- 注文ステータスを「キャンセル」に更新
- 顧客に決済失敗メールを送信
- 在庫解放は補償トランザクション（Saga パターン）で実装

#### AC-4: 冪等性の保証（重複リクエスト対策）
**Given** 同一リクエストの再送（ネットワークリトライ/クライアント再試行）が発生する  
**When** 冪等キー（Idempotency-Key）を付与して再送される  
**Then** 二重課金や二重ロックが発生せず、同一リクエストは一度だけ処理される

**詳細説明:**
- Idempotency-Keyをリクエストヘッダーで受け取る
- 既に処理済みのキーの場合は前回のレスポンスを返す
- Idempotency-Keyの有効期限は24時間
- データベースにIdempotency-Keyと処理結果を保存

#### AC-5: 複数拠点在庫からの最適引当
**Given** 同一SKUが東京倉庫と大阪倉庫に在庫がある  
**When** 注文確定時に在庫を引き当てる  
**Then** 配送先に最も近い倉庫から優先的に在庫がロックされる

**詳細説明:**
- 在庫引当アルゴリズムは設定可能（距離優先、在庫量優先、優先度）
- 複数拠点から分割引当も可能
- 引当拠点情報はShipmentテーブルに記録
- 拠点選択ロジックは在庫サービス内で実装

#### AC-6: 高負荷時のパフォーマンス要件
**Given** ピーク時に秒間1000件の注文確定リクエストが発生  
**When** 負荷試験を実施  
**Then** 注文確定APIのP99レスポンスタイムが2秒以内

**詳細説明:**
- 在庫ロック処理は分散ロック（Redis Redlock）で最適化
- データベースコネクションプーリングを適切に設定
- 在庫キャッシュ（Redis）を活用して読み取り負荷を軽減
- 書き込みはデータベースに直接実施（キャッシュは参照のみ）

### 非機能要件

#### パフォーマンス
- [ ] 在庫ロックAPIのP99レスポンスタイム: 2秒以内（ピーク時）
- [ ] 同一SKUへの1000並列ロックでデータ不整合が発生しない
- [ ] 在庫ロックのタイムアウト: 5秒
- [ ] 冪等性チェックのオーバーヘッド: 50ms以内

#### セキュリティ
- [ ] ユーザーは自分の注文のみロック可能（認可チェック必須）
- [ ] 権限のないユーザーが他者の注文IDを指定した場合は403エラー
- [ ] Idempotency-Keyの予測不可能性（UUID v4推奨）
- [ ] 在庫操作の監査ログ記録

#### 可用性
- [ ] 在庫サービスダウン時はサーキットブレーカーで注文を一時停止
- [ ] エラー時は顧客に再試行を促すメッセージを表示
- [ ] 在庫ロックの自動解放（24時間後に未決済の場合）

#### 保守性
- [ ] 在庫ロック/解放の全操作を監査ログに記録
- [ ] 在庫不整合検知の自動アラート
- [ ] 定期的なバックグラウンド整合性チェックジョブ
- [ ] 在庫ロックIDによる追跡可能性

## UI/UX要件

### 画面遷移
```
[カート画面] → [注文確認画面] → [注文確定処理中] → [注文完了画面]
                                      ↓
                              [在庫不足エラー画面]
```

### ワイヤーフレーム
- **注文確認画面**: 「注文を確定する」ボタン
- **処理中画面**: ローディングスピナー、「在庫を確保しています...」メッセージ
- **完了画面**: 「注文が確定しました。発送準備を開始します。」
- **エラー画面**: 「申し訳ありません。在庫不足のため注文できませんでした。」

### インタラクション
- 注文確定ボタン押下時に確認ダイアログ表示
- 処理中はボタンを無効化し、二重送信を防止
- 在庫確保中はローディングスピナーとステータスメッセージを表示
- エラー時は在庫切れ商品を赤色でハイライト表示

## 技術要件

### API仕様

#### エンドポイント: 注文確定（在庫ロック含む）
- **メソッド:** POST
- **パス:** `/api/v1/orders/confirm`
- **認証:** Required（JWT）

**リクエストヘッダー:**
```
Authorization: Bearer {jwt_token}
Idempotency-Key: {uuid_v4}
```

**リクエスト:**
```json
{
  "cartId": "cart_123456",
  "shippingAddressId": "addr_789",
  "paymentMethod": {
    "type": "credit_card",
    "paymentToken": "tok_visa_1234"
  }
}
```

**レスポンス（成功時）:**
```json
{
  "status": "success",
  "data": {
    "orderId": "ord_202511110001",
    "orderNumber": "ECF-20251111-0001",
    "status": "reserved",
    "inventoryAllocations": [
      {
        "skuId": "sku_ABC123",
        "quantity": 2,
        "locationId": "loc_tokyo",
        "inventoryLockId": "lock_001"
      }
    ],
    "totalAmount": 5960,
    "createdAt": "2025-11-11T10:30:00Z"
  }
}
```

**レスポンス（在庫不足エラー）:**
```json
{
  "status": "error",
  "error": {
    "code": "INSUFFICIENT_INVENTORY",
    "message": "在庫不足のため注文できません",
    "details": [
      {
        "skuId": "sku_ABC123",
        "requestedQuantity": 2,
        "availableQuantity": 1
      }
    ]
  }
}
```

**レスポンス（冪等性チェック - 既に処理済み）:**
```json
{
  "status": "success",
  "data": {
    "orderId": "ord_202511110001",
    "alreadyProcessed": true,
    "message": "この注文は既に処理されています"
  }
}
```

### データモデル

#### エンティティ: Inventory（在庫テーブル）
```
Inventory:
- inventoryId: UUID (主キー)
- skuId: UUID (外部キー -> SKU)
- locationId: UUID (外部キー -> InventoryLocation)
- physicalQuantity: Integer (物理在庫数)
- allocatedQuantity: Integer (引当済数)
- reservedQuantity: Integer (ロック済数、未決済)
- safetyStock: Integer (安全在庫数)
- version: Integer (楽観ロック用バージョン)
- updatedAt: Timestamp
```

計算フィールド:
- availableQuantity = physicalQuantity - allocatedQuantity - reservedQuantity - safetyStock

#### エンティティ: InventoryAllocation（在庫引当）
```
InventoryAllocation:
- allocationId: UUID (主キー)
- orderId: UUID (外部キー -> Order)
- status: Enum (reserved, allocated, released)
- createdAt: Timestamp
- expiresAt: Timestamp (24時間後に自動解放)
- releasedAt: Timestamp (null可)
```

#### エンティティ: AllocationLine（引当明細）
```
AllocationLine:
- allocationLineId: UUID (主キー)
- allocationId: UUID (外部キー -> InventoryAllocation)
- inventoryId: UUID (外部キー -> Inventory)
- skuId: UUID (外部キー -> SKU)
- quantity: Integer
- inventoryLockId: String (一意、追跡用)
- createdAt: Timestamp
```

#### エンティティ: IdempotencyKey（冪等性管理）
```
IdempotencyKey:
- idempotencyKeyId: UUID (主キー)
- idempotencyKey: String (一意、インデックス)
- requestHash: String (リクエスト内容のハッシュ)
- responseData: JSONB (処理結果のキャッシュ)
- expiresAt: Timestamp (24時間後)
- createdAt: Timestamp
```

### ビジネスルール参照
- [BR-INV-001: 注文確定時に在庫を即時ロックする](../business-rule/BR-INV-001_注文確定時に在庫を即時ロックする.md)
- BR-INV-002: 在庫数は負数にならない
- BR-INV-005: 在庫ロックの有効期限は24時間（未決済の場合自動解放）

## 依存関係

### 前提条件
- [ ] ユーザー認証機能が実装済み
- [ ] カート管理機能が実装済み
- [ ] SKUマスタが構築されている
- [ ] 倉庫拠点（InventoryLocation）が登録されている
- [ ] Redis（分散ロック用）が利用可能
- [ ] PostgreSQL（トランザクション分離レベル: READ COMMITTED以上）

### 依存するストーリー
- なし（最優先の基盤ストーリー）

### ブロッカー
- なし

## テスト戦略

### 単体テスト
- [ ] 在庫ロックロジック（成功ケース、不足ケース）
- [ ] 在庫解放ロジック
- [ ] 冪等性チェックロジック
- [ ] 在庫計算ロジック（availableQuantity）
- [ ] カバレッジ目標: 95%以上

### 統合テスト
- [ ] 在庫ロック→決済成功→在庫確定のフロー
- [ ] 在庫ロック→決済失敗→在庫解放のフロー
- [ ] 複数拠点からの引当
- [ ] トランザクション整合性（ロールバック含む）
- [ ] 冪等性（同一Idempotency-Keyの再送）

### E2Eテスト
- [ ] 注文確定→在庫ロック→決済→出荷のフルフロー
- [ ] 在庫不足時のエラー表示
- [ ] 決済失敗時の在庫解放とキャンセル

### 性能テスト
- [ ] **並列負荷試験（最重要）**: 同一SKUへの1000並列注文でオーバーセルが発生しない
- [ ] 注文確定API: 1000 req/sec で P99 < 2秒
- [ ] 在庫ロックの競合時リトライ成功率
- [ ] データベースデッドロックの発生率（0%目標）

### 負荷テスト
- [ ] ピーク時想定（秒間1000注文）での在庫整合性維持
- [ ] Redis障害時のフォールバック動作確認
- [ ] データベース負荷分散（読み取りレプリカ）の効果測定

## 実装計画

### タスク分解
1. [ ] データモデル設計とマイグレーション
   - 見積もり: 4時間
   - 担当: バックエンドエンジニア
2. [ ] 在庫ロックAPI実装（楽観ロック方式）
   - 見積もり: 12時間
   - 担当: バックエンドエンジニア
3. [ ] 在庫解放API実装（補償トランザクション）
   - 見積もり: 6時間
   - 担当: バックエンドエンジニア
4. [ ] 冪等性チェック機構実装
   - 見積もり: 6時間
   - 担当: バックエンドエンジニア
5. [ ] 分散ロック実装（Redis Redlock）
   - 見積もり: 8時間
   - 担当: バックエンドエンジニア
6. [ ] 複数拠点引当アルゴリズム実装
   - 見積もり: 8時間
   - 担当: バックエンドエンジニア
7. [ ] フロントエンド実装（処理中UI、エラー表示）
   - 見積もり: 6時間
   - 担当: フロントエンドエンジニア
8. [ ] テスト実装（単体・統合・E2E・性能・負荷）
   - 見積もり: 20時間
   - 担当: QAエンジニア

### 技術的考慮事項
- **楽観ロック**: Inventoryテーブルのversionカラムで競合検知、UPDATE失敗時はリトライ（Exponential Backoff）
- **分散ロック**: Redis Redlockで在庫ロック取得（タイムアウト5秒）
- **トランザクション設計**: 在庫ロック→注文作成→決済を別トランザクションに分離（Saga パターン）
- **冪等性**: Idempotency-Keyをユニーク制約で保証、24時間TTLで自動削除
- **サーキットブレーカー**: 在庫サービスの障害時は注文受付を一時停止
- **監査ログ**: 全在庫操作をInventoryTransactionに記録

### リスクと対策
| リスク | 影響度 | 対策 |
|--------|--------|------|
| 在庫競合によるロック失敗 | High | 楽観ロック + リトライロジック（最大3回） |
| データベースデッドロック | High | ロック順序の統一、トランザクションタイムアウト設定 |
| Redis障害によるロック不可 | Medium | DBの悲観ロックにフォールバック |
| 在庫数の不整合（バグ） | High | トランザクション履歴から再計算、定期監査ジョブ |
| 高負荷時のパフォーマンス劣化 | Medium | 水平スケール、読み取りレプリカ活用 |

## 完了の定義（Definition of Done）

- [ ] コードが実装され、レビューが完了している
- [ ] 全ての受入基準が満たされている
- [ ] 単体テストが実装され、全てパスしている（カバレッジ95%以上）
- [ ] 統合テストが実装され、全てパスしている
- [ ] **並列負荷試験が完了し、1000並列で在庫不整合が発生しない**
- [ ] 性能テストが完了し、P99 < 2秒を満たしている
- [ ] セキュリティレビューが完了している
- [ ] API仕様書が更新されている（OpenAPI/Swagger）
- [ ] ステージング環境でのテストが完了している
- [ ] プロダクトオーナーによる受入テストが完了している
- [ ] 監視・アラート設定が完了している（在庫不整合検知、ロック失敗率等）

## 参考資料

### 関連ドキュメント
- [プロジェクト概要](../project-overview.md)
- [在庫テーブル定義](../data/schema/inventory.sql)
- [注文テーブル定義](../data/schema/order.sql)
- [BR-INV-001: 在庫ロックビジネスルール](../business-rule/BR-INV-001_注文確定時に在庫を即時ロックする.md)

### 外部参照
- [Redlock分散ロックアルゴリズム](https://redis.io/topics/distlock)
- [楽観ロックパターン](https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html)
- [Saga パターン（補償トランザクション）](https://microservices.io/patterns/data/saga.html)
- [PostgreSQL トランザクション分離](https://www.postgresql.org/docs/current/transaction-iso.html)
- [冪等性とIdempotency-Key](https://stripe.com/docs/api/idempotent_requests)

## 備考・コメント

### 設計上の決定事項
- 在庫ロックは楽観ロックを基本とし、高負荷時は分散ロック（Redlock）を併用
- 決済は非同期処理とし、在庫ロックと分離（Saga パターン）
- 在庫ロックの有効期限は24時間（未決済の場合自動解放）
- 冪等性保証のためIdempotency-Keyを必須化

### 技術的負債
- 予約在庫の細かい管理は将来対応
- AI予測による動的在庫割当は将来対応

### 将来の拡張性
- リアルタイム在庫可視化ダッシュボード
- AIによる需要予測と在庫最適化
- 分散トランザクション（2PC）への移行検討

---

## 変更履歴

| 日付 | 変更者 | 変更内容 |
|------|--------|----------|
| 2025-11-11 | AI Assistant | テンプレート形式に準拠して再作成 |
