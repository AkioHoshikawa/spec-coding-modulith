# ユーザーストーリー：在庫管理と在庫ロック機能

## 基本情報

| 項目 | 内容 |
|------|------|
| **ID** | US-004 |
| **タイトル** | リアルタイム在庫管理と在庫ロック機能の実装 |
| **ステータス** | Draft |
| **優先度** | High |
| **見積もり** | 13ストーリーポイント |
| **担当者** | 未割当 |
| **作成日** | 2025-11-11 |
| **更新日** | 2025-11-11 |

## ユーザーストーリー

**As a** システム管理者  
**I want** SKU単位で在庫を管理し、注文時に即座に在庫をロックできる  
**So that** ピーク時でも在庫整合性を保ち、オーバーセルを防止できる

### 日本語記述

システム管理者として、ピーク時の大量注文でもオーバーセルを防止するために、リアルタイムで在庫を管理し注文確定時に即座に在庫をロックできる機能が必要である。

## 背景・目的

### ビジネス背景
ファッションECでは、セールやタイムセール時に秒間数千のリクエストが集中し、同一商品への同時注文が頻発する。在庫管理の不備はオーバーセル（販売可能数を超えた受注）を引き起こし、顧客満足度の低下や業務負荷の増大につながる。プロジェクト概要では、「ピーク時における在庫整合性の保持」が明確な要件として定義されている。

### ユーザーニーズ
- **顧客視点**: 注文確定時に在庫があることを保証してほしい
- **運営視点**: オーバーセルによる顧客対応コストを削減したい
- **倉庫視点**: 正確な在庫数に基づいてピッキング作業を行いたい
- **マーケティング視点**: 在庫連動でプロモーションを自動制御したい

### 現状の課題
- 在庫数の更新タイミングによる不整合リスク
- 複数拠点（倉庫）の在庫を統合管理する必要性
- カートに追加した商品と注文確定時の在庫ギャップ
- 予約販売、セール在庫など特殊な在庫タイプへの対応

## 受入基準（Acceptance Criteria）

### 機能要件

#### AC-1: SKU単位の在庫数管理
**Given** SKUマスタに商品が登録されている  
**When** 各倉庫拠点ごとに在庫数を登録・更新する  
**Then** SKUと倉庫拠点の組み合わせで在庫数が管理される

**詳細説明:**
- 在庫数は倉庫拠点（InventoryLocation）ごとに管理
- 在庫数には「物理在庫」「引当可能在庫」「引当済在庫」の区別がある
- 在庫数は負数にならない（バリデーション）
- 在庫数変更は全てInventoryTransactionとして履歴記録

#### AC-2: 注文確定時の在庫ロック（原子操作）
**Given** ユーザーが注文を確定する  
**When** 在庫引当APIが呼び出される  
**Then** 対象SKUの在庫が原子的にロックされ、引当済在庫にカウントされる

**詳細説明:**
- 在庫ロックは楽観ロックまたは悲観ロック（またはその組合せ）で実装
- ロック処理中に他のトランザクションが同じ在庫を減らせない
- 在庫不足の場合は即座にエラーを返す（ロールバック）
- 在庫ロックIDを発行し、OrderLineに記録して追跡可能にする
- ロック処理のタイムアウトは5秒

#### AC-3: 在庫ロックの解放（キャンセル・決済失敗時）
**Given** 注文確定後に決済が失敗またはキャンセルされる  
**When** 在庫ロック解放APIが呼び出される  
**Then** 引当済在庫が引当可能在庫に戻される

**詳細説明:**
- 在庫ロック解放は必ずInventoryTransactionに記録
- 解放処理も原子的に実施（部分的な解放は許可しない）
- 解放理由（キャンセル、決済失敗、返品等）を記録

#### AC-4: 複数拠点在庫の最適引当
**Given** 同一SKUが複数倉庫に在庫がある  
**When** 注文確定時に在庫を引き当てる  
**Then** 配送先に最も近い倉庫から優先的に引き当てる

**詳細説明:**
- 在庫引当アルゴリズムは設定可能（優先度、距離、在庫量など）
- デフォルトは「配送先に最も近い倉庫」を優先
- 在庫が複数拠点に分散している場合、複数拠点から引当可能
- 拠点間の在庫移動（Transfer）も記録可能

#### AC-5: 在庫数のリアルタイム参照
**Given** ユーザーが商品詳細ページを閲覧  
**When** 在庫状況を確認する  
**Then** リアルタイムの引当可能在庫数が表示される

**詳細説明:**
- 「在庫あり」「残りわずか（5個以下）」「在庫切れ」の3段階表示
- 引当可能在庫 = 物理在庫 - 引当済在庫 - 安全在庫
- キャッシュ（Redis）を活用し、P95レスポンスタイム50ms以内
- キャッシュ更新は在庫変動時に即座に実施

#### AC-6: 在庫トランザクション履歴の記録
**Given** 在庫数が変動する操作が発生  
**When** 入庫、出庫、引当、解放、調整などが実施される  
**Then** 全ての在庫変動がInventoryTransactionに記録される

**詳細説明:**
- トランザクションタイプ（入庫、出庫、引当、解放、調整、移動）
- 変動前数量、変動量、変動後数量
- 関連する注文ID、オペレーターID、理由
- タイムスタンプと監査ログ

### 非機能要件

#### パフォーマンス
- [ ] 在庫参照APIのP95レスポンスタイム: 50ms以内
- [ ] 在庫ロックAPIのP99レスポンスタイム: 200ms以内
- [ ] 同一SKUへの同時1000並列ロックリクエストでデータ不整合が発生しない
- [ ] 在庫更新の遅延: 1秒以内にキャッシュに反映

#### セキュリティ
- [ ] 在庫操作は認可チェック必須（管理者権限）
- [ ] 在庫数の直接変更は監査ログに記録
- [ ] APIアクセスはレート制限

#### 可用性
- [ ] 在庫サービスのSLA: 99.95%
- [ ] Redisダウン時はDBから直接取得（パフォーマンス劣化を許容）

#### 保守性
- [ ] 在庫不整合検知の自動アラート
- [ ] 在庫数が負数になる異常を即座に検知
- [ ] 在庫トランザクション履歴から任意時点の在庫数を再計算可能

## UI/UX要件

### 画面遷移
```
[在庫一覧] → [在庫詳細] → [在庫調整]
     ↓
[在庫履歴]
```

### ワイヤーフレーム
- **在庫一覧画面**: SKU一覧、各拠点の在庫数、引当可能数、警告表示
- **在庫詳細画面**: SKU情報、拠点別在庫数、在庫トランザクション履歴
- **在庫調整画面**: 在庫数入力、調整理由入力、確認ボタン

### インタラクション
- 在庫数が閾値以下の場合は警告色（黄色・赤）で表示
- 在庫調整時は確認ダイアログを表示
- 在庫トランザクション履歴はページネーション対応

## 技術要件

### API仕様

#### エンドポイント: 在庫参照
- **メソッド:** GET
- **パス:** `/api/v1/inventory/{skuId}`
- **認証:** Optional

**レスポンス（成功時）:**
```json
{
  "status": "success",
  "data": {
    "skuId": "sku_ABC123",
    "locations": [
      {
        "locationId": "loc_tokyo",
        "locationName": "東京倉庫",
        "physicalQuantity": 100,
        "allocatedQuantity": 20,
        "availableQuantity": 80
      },
      {
        "locationId": "loc_osaka",
        "locationName": "大阪倉庫",
        "physicalQuantity": 50,
        "allocatedQuantity": 10,
        "availableQuantity": 40
      }
    ],
    "totalAvailable": 120
  }
}
```

#### エンドポイント: 在庫ロック（引当）
- **メソッド:** POST
- **パス:** `/api/v1/inventory/allocate`
- **認証:** Required（内部サービス用トークン）

**リクエスト:**
```json
{
  "orderId": "ord_123456",
  "items": [
    {
      "skuId": "sku_ABC123",
      "quantity": 2,
      "preferredLocationId": "loc_tokyo"
    }
  ]
}
```

**レスポンス（成功時）:**
```json
{
  "status": "success",
  "data": {
    "allocationId": "alloc_789",
    "allocations": [
      {
        "skuId": "sku_ABC123",
        "locationId": "loc_tokyo",
        "quantity": 2,
        "inventoryLockId": "lock_001"
      }
    ]
  }
}
```

**レスポンス（在庫不足エラー）:**
```json
{
  "status": "error",
  "error": {
    "code": "INSUFFICIENT_INVENTORY",
    "message": "在庫不足",
    "details": [
      {
        "skuId": "sku_ABC123",
        "requestedQuantity": 2,
        "availableQuantity": 1
      }
    ]
  }
}
```

#### エンドポイント: 在庫ロック解放
- **メソッド:** POST
- **パス:** `/api/v1/inventory/release`
- **認証:** Required（内部サービス用トークン）

**リクエスト:**
```json
{
  "allocationId": "alloc_789",
  "reason": "payment_failed"
}
```

**レスポンス（成功時）:**
```json
{
  "status": "success",
  "data": {
    "releasedItems": [
      {
        "skuId": "sku_ABC123",
        "quantity": 2
      }
    ]
  }
}
```

### データモデル

#### エンティティ: SKU
```
SKU:
- skuId: UUID (主キー)
- productId: UUID (外部キー -> Product)
- skuCode: String (一意、ビジネスキー)
- size: String
- color: String
- price: Decimal
- isActive: Boolean
- createdAt: Timestamp
- updatedAt: Timestamp
```

#### エンティティ: InventoryLocation
```
InventoryLocation:
- locationId: UUID (主キー)
- locationCode: String (一意)
- locationName: String
- locationType: Enum (warehouse, store, virtual)
- address: String
- isActive: Boolean
- priority: Integer (引当優先度)
- createdAt: Timestamp
```

#### エンティティ: Inventory
```
Inventory:
- inventoryId: UUID (主キー)
- skuId: UUID (外部キー -> SKU)
- locationId: UUID (外部キー -> InventoryLocation)
- physicalQuantity: Integer (物理在庫数)
- allocatedQuantity: Integer (引当済数)
- safetyStock: Integer (安全在庫数)
- version: Integer (楽観ロック用バージョン)
- updatedAt: Timestamp
- UNIQUE(skuId, locationId)
```

計算フィールド:
- availableQuantity = physicalQuantity - allocatedQuantity - safetyStock

#### エンティティ: InventoryTransaction
```
InventoryTransaction:
- transactionId: UUID (主キー)
- inventoryId: UUID (外部キー -> Inventory)
- transactionType: Enum (receive, ship, allocate, release, adjust, transfer)
- quantityBefore: Integer
- quantityChange: Integer (正または負)
- quantityAfter: Integer
- relatedOrderId: UUID (null可)
- relatedAllocationId: UUID (null可)
- reason: String
- operatorId: UUID (null可)
- createdAt: Timestamp
```

#### エンティティ: InventoryAllocation
```
InventoryAllocation:
- allocationId: UUID (主キー)
- orderId: UUID (外部キー -> Order)
- status: Enum (allocated, released, shipped)
- createdAt: Timestamp
- releasedAt: Timestamp (null可)
```

#### エンティティ: AllocationLine
```
AllocationLine:
- allocationLineId: UUID (主キー)
- allocationId: UUID (外部キー -> InventoryAllocation)
- inventoryId: UUID (外部キー -> Inventory)
- skuId: UUID (外部キー -> SKU)
- quantity: Integer
- inventoryLockId: String (一意、追跡用)
- createdAt: Timestamp
```

#### リレーションシップ
- SKU 1:N Inventory
- InventoryLocation 1:N Inventory
- Inventory 1:N InventoryTransaction
- Order 1:1 InventoryAllocation
- InventoryAllocation 1:N AllocationLine

### ビジネスルール参照
- [BR-INV-001: 注文確定時に在庫を即時ロックする](../business-rule/BR-INV-001_注文確定時に在庫を即時ロックする.md)
- BR-INV-002: 在庫数は負数にならない
- BR-INV-003: 安全在庫を下回る場合は発注アラートを発行
- BR-INV-004: 在庫引当の有効期限は24時間（未出荷の場合自動解放）

## 依存関係

### 前提条件
- [ ] SKUマスタが構築されている
- [ ] 倉庫拠点（InventoryLocation）が登録されている
- [ ] データベース（PostgreSQL）でトランザクション分離レベルが適切に設定されている
- [ ] Redis（キャッシュ・分散ロック用）が利用可能

### 依存するストーリー
- なし（基盤的なストーリー）

### ブロッカー
- 在庫ロック戦略の技術選定（楽観ロック vs 悲観ロック vs 分散ロック）
- 初期在庫データのインポート方法

## テスト戦略

### 単体テスト
- [ ] 在庫引当ロジック（成功ケース、不足ケース）
- [ ] 在庫解放ロジック
- [ ] 在庫計算ロジック（availableQuantity）
- [ ] バリデーション（負数チェック）
- [ ] カバレッジ目標: 90%以上

### 統合テスト
- [ ] 在庫ロック→解放のフロー
- [ ] 複数拠点からの引当
- [ ] トランザクション整合性（ロールバック含む）
- [ ] キャッシュとDBの整合性

### E2Eテスト
- [ ] 注文確定時の在庫引当→出荷→在庫減少のフロー
- [ ] 決済失敗時の在庫解放
- [ ] 返品時の在庫復元

### 性能テスト
- [ ] 同一SKUへの1000並列在庫ロックでデータ不整合が発生しない
- [ ] 在庫参照API: 10000 req/sec で P95 < 50ms
- [ ] 在庫ロックAPI: 1000 req/sec で P99 < 200ms
- [ ] 楽観ロックの競合時リトライ成功率

### 負荷テスト
- [ ] ピーク時想定（秒間1000注文）での在庫整合性維持
- [ ] Redis障害時のフォールバック動作確認

## 実装計画

### タスク分解
1. [ ] データモデル設計とマイグレーション
   - 見積もり: 8時間
   - 担当: バックエンドエンジニア
2. [ ] 在庫参照API実装（キャッシュ含む）
   - 見積もり: 8時間
   - 担当: バックエンドエンジニア
3. [ ] 在庫ロック（引当）API実装
   - 見積もり: 16時間
   - 担当: バックエンドエンジニア
4. [ ] 在庫解放API実装
   - 見積もり: 8時間
   - 担当: バックエンドエンジニア
5. [ ] 在庫トランザクション記録機構
   - 見積もり: 6時間
   - 担当: バックエンドエンジニア
6. [ ] 複数拠点引当アルゴリズム実装
   - 見積もり: 10時間
   - 担当: バックエンドエンジニア
7. [ ] 在庫管理画面UI実装
   - 見積もり: 12時間
   - 担当: フロントエンドエンジニア
8. [ ] テスト実装（単体・統合・E2E・性能）
   - 見積もり: 16時間
   - 担当: QAエンジニア

### 技術的考慮事項
- **楽観ロック**: Inventoryテーブルにversionカラムを追加し、UPDATE時にバージョンチェック
- **分散ロック**: Redlockアルゴリズムを使用してRedisで在庫ロックを取得
- **キャッシュ戦略**: Write-Through（書き込み時に即座にキャッシュ更新）
- **トランザクション分離レベル**: READ_COMMITTED以上（PostgreSQLデフォルト）
- **インデックス**: (skuId, locationId)の複合ユニークインデックス、transactionTypeでのインデックス

### リスクと対策
| リスク | 影響度 | 対策 |
|--------|--------|------|
| 在庫競合によるロック失敗 | High | 楽観ロック + リトライロジック（Exponential Backoff） |
| Redis障害によるキャッシュ不整合 | Medium | DBからのフォールバック、定期的な整合性チェック |
| データベースデッドロック | Medium | ロック順序の統一、トランザクションタイムアウト設定 |
| 在庫数の不整合（バグ） | High | トランザクション履歴から再計算可能な設計、定期監査 |

## 完了の定義（Definition of Done）

- [ ] コードが実装され、レビューが完了している
- [ ] 全ての受入基準が満たされている
- [ ] 単体テストが実装され、全てパスしている（カバレッジ90%以上）
- [ ] 統合テストが実装され、全てパスしている
- [ ] 性能テストが完了し、1000並列ロックで不整合が発生しない
- [ ] 負荷テストが完了し、SLA基準を満たしている
- [ ] セキュリティレビューが完了している
- [ ] API仕様書が更新されている
- [ ] ステージング環境でのテストが完了している
- [ ] プロダクトオーナーによる受入テストが完了している
- [ ] 監視・アラート設定が完了している

## 参考資料

### 関連ドキュメント
- [プロジェクト概要](../project-overview.md)
- [在庫テーブル定義](../data/schema/inventory.sql)
- [BR-INV-001: 在庫ロックビジネスルール](../business-rule/BR-INV-001_注文確定時に在庫を即時ロックする.md)

### 外部参照
- [Redlock分散ロックアルゴリズム](https://redis.io/topics/distlock)
- [楽観ロックパターン](https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html)
- [PostgreSQL トランザクション分離](https://www.postgresql.org/docs/current/transaction-iso.html)

## 備考・コメント

### 設計上の決定事項
- 在庫ロックは楽観ロックを基本とし、高負荷時は分散ロック（Redlock）を併用
- 在庫数の計算は常にDB上で実施（キャッシュは参照のみ）
- 在庫トランザクション履歴は無期限保存（監査要件）

### 技術的負債
- オムニチャネル（店舗在庫との統合）は将来対応
- 予約在庫の細かい管理は将来対応
- 自動発注機能は将来対応

### 将来の拡張性
- 店舗在庫との統合（オムニチャネル）
- AIによる需要予測と自動発注
- 在庫最適化アルゴリズム（拠点間移動の最適化）
- リアルタイム在庫同期（外部WMSとの連携）

---

## 変更履歴

| 日付 | 変更者 | 変更内容 |
|------|--------|----------|
| 2025-11-11 | AI Assistant | 初版作成 |
